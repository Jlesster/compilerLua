--- C++ language actions with enhanced autodetection

local M = {}

-- Cache for pkg-config checks to avoid repeated system calls
local pkg_cache = {}

-- Helper: detect and get flags for a library using pkg-config (cached)
local function get_pkg_config_flags(lib_name)
  if pkg_cache[lib_name] ~= nil then
    return pkg_cache[lib_name]
  end

  local handle = io.popen("pkg-config --cflags --libs " .. lib_name .. " 2>/dev/null")
  if not handle then
    pkg_cache[lib_name] = false
    return nil
  end
  local flags = handle:read("*a")
  handle:close()

  if flags and flags ~= "" then
    flags = flags:gsub("\n", "")
    pkg_cache[lib_name] = flags
    return flags
  end
  pkg_cache[lib_name] = false
  return nil
end

-- Helper: check if a library exists via pkg-config (cached)
local function check_pkg_config(lib_name)
  if pkg_cache[lib_name] ~= nil then
    return pkg_cache[lib_name] ~= false
  end

  local handle = io.popen("pkg-config --exists " .. lib_name .. " 2>/dev/null && echo 'yes'")
  if not handle then
    pkg_cache[lib_name] = false
    return false
  end
  local result = handle:read("*a")
  handle:close()
  local exists = result:match("yes") ~= nil
  if not exists then
    pkg_cache[lib_name] = false
  end
  return exists
end

-- Helper: scan source files for #include directives (optimized)
local function scan_includes(files)
  local includes = {}
  local file_set = {}

  -- Parse file list
  local file_list = {}
  for file in files:gmatch("[^%s]+") do
    local clean_file = file:gsub('"', '')
    if not file_set[clean_file] then
      file_set[clean_file] = true
      table.insert(file_list, clean_file)
    end
  end

  -- Scan each file for includes
  for _, file in ipairs(file_list) do
    local f = io.open(file, "r")
    if f then
      for line in f:lines() do
        -- Match #include <library> or #include "library"
        local include = line:match('#include%s*[<"]([^>"]+)[>"]')
        if include then
          includes[include] = true
        end
      end
      f:close()
    end
  end

  return includes
end

-- Helper: comprehensive include to library mapping
local function map_include_to_library(include)
  local mapping = {
    -- SDL libraries (prefer SDL3 > SDL2)
    ["SDL3/SDL.h"] = {"sdl3"},
    ["SDL2/SDL.h"] = {"sdl2"},
    ["SDL.h"] = {"sdl3", "sdl2"},
    ["SDL2/SDL_image.h"] = {"SDL2_image"},
    ["SDL3/SDL_image.h"] = {"SDL3_image"},
    ["SDL2/SDL_ttf.h"] = {"SDL2_ttf"},
    ["SDL3/SDL_ttf.h"] = {"SDL3_ttf"},
    ["SDL2/SDL_mixer.h"] = {"SDL2_mixer"},
    ["SDL3/SDL_mixer.h"] = {"SDL3_mixer"},
    ["SDL2/SDL_net.h"] = {"SDL2_net"},
    ["SDL3/SDL_net.h"] = {"SDL3_net"},

    -- SDL OpenGL integration (requires OpenGL linking)
    ["SDL3/SDL_opengl.h"] = {"sdl3"},  -- Will trigger GL detection
    ["SDL2/SDL_opengl.h"] = {"sdl2"},  -- Will trigger GL detection

    -- OpenGL/Graphics (prefer modern alternatives)
    ["GLFW/glfw3.h"] = {"glfw3"},
    ["GL/glew.h"] = {"glew"},
    ["GL/gl.h"] = {"gl"},
    ["GL/glu.h"] = {"glu"},
    ["GL/glut.h"] = {"freeglut", "glut"},
    ["GL/freeglut.h"] = {"freeglut"},
    ["GLUT/glut.h"] = {"freeglut", "glut"},
    ["vulkan/vulkan.h"] = {"vulkan"},
    ["vulkan/vulkan.hpp"] = {"vulkan"},

    -- GLFW alternatives
    ["glad/glad.h"] = {"glad"},
    ["glad/gl.h"] = {"glad"},

    -- UI Libraries (prefer GTK4 > GTK3)
    ["gtk/gtk.h"] = {"gtk4", "gtk+-3.0"},
    ["gtk-4.0/gtk/gtk.h"] = {"gtk4"},
    ["gtk-3.0/gtk/gtk.h"] = {"gtk+-3.0"},
    ["qt5/QtCore/QCoreApplication"] = {"Qt5Core"},
    ["qt6/QtCore/QCoreApplication"] = {"Qt6Core"},
    ["QCoreApplication"] = {"Qt6Core", "Qt5Core"},

    -- Audio
    ["AL/al.h"] = {"openal"},
    ["AL/alc.h"] = {"openal"},
    ["portaudio.h"] = {"portaudio-2.0"},
    ["pulse/pulseaudio.h"] = {"libpulse"},
    ["sndfile.h"] = {"sndfile"},
    ["SFML/Audio.hpp"] = {"sfml-audio"},
    ["FMOD/fmod.h"] = {},  -- FMOD requires manual setup

    -- Math/Physics
    ["Eigen/Dense"] = {"eigen3"},
    ["eigen3/Eigen/Dense"] = {"eigen3"},
    ["glm/glm.hpp"] = {"glm"},
    ["bullet/btBulletDynamicsCommon.h"] = {"bullet"},
    ["Box2D/Box2D.h"] = {"box2d"},

    -- Networking
    ["curl/curl.h"] = {"libcurl"},
    ["zmq.h"] = {"libzmq"},
    ["asio.hpp"] = {"asio"},
    ["boost/asio.hpp"] = {"boost"},

    -- Image/Video
    ["ft2build.h"] = {"freetype2"},
    ["freetype2/ft2build.h"] = {"freetype2"},
    ["png.h"] = {"libpng"},
    ["jpeglib.h"] = {"libjpeg"},
    ["webp/decode.h"] = {"libwebp"},
    ["zlib.h"] = {"zlib"},
    ["opencv2/opencv.hpp"] = {"opencv4", "opencv"},
    ["opencv4/opencv2/opencv.hpp"] = {"opencv4"},

    -- Game engines/frameworks
    ["SFML/Graphics.hpp"] = {"sfml-graphics", "sfml-window", "sfml-system"},
    ["SFML/Window.hpp"] = {"sfml-window", "sfml-system"},
    ["SFML/System.hpp"] = {"sfml-system"},
    ["raylib.h"] = {"raylib"},

    -- Data formats
    ["json.hpp"] = {},  -- nlohmann-json is header-only
    ["yaml-cpp/yaml.h"] = {"yaml-cpp"},
    ["pugixml.hpp"] = {"pugixml"},
    ["sqlite3.h"] = {"sqlite3"},
    ["postgresql/libpq-fe.h"] = {"libpq"},
    ["mysql/mysql.h"] = {"mysqlclient"},

    -- Threading/Concurrency
    ["tbb/tbb.h"] = {"tbb"},
    ["omp.h"] = {},  -- OpenMP via compiler flag
  }

  return mapping[include] or {}
end

-- Helper: determine priority between library versions
local function get_library_priority()
  return {
    -- Graphics (prefer newer/better)
    ["sdl3"] = 100,
    ["sdl2"] = 50,
    ["SDL3_image"] = 100,
    ["SDL2_image"] = 50,
    ["SDL3_ttf"] = 100,
    ["SDL2_ttf"] = 50,
    ["SDL3_mixer"] = 100,
    ["SDL2_mixer"] = 50,
    ["SDL3_net"] = 100,
    ["SDL2_net"] = 50,

    -- UI (prefer GTK4 > GTK3, Qt6 > Qt5)
    ["gtk4"] = 100,
    ["gtk+-3.0"] = 50,
    ["Qt6Core"] = 100,
    ["Qt5Core"] = 50,

    -- OpenGL utilities (prefer freeglut > glut)
    ["freeglut"] = 100,
    ["glut"] = 50,

    -- Computer Vision
    ["opencv4"] = 100,
    ["opencv"] = 50,
  }
end

-- Helper: autodetect libraries based on actual includes
local function autodetect_libraries(files)
  -- Scan source files for includes
  local includes = scan_includes(files)

  -- Build list of required libraries based on includes
  local required_libs = {}
  local lib_set = {}

  for include, _ in pairs(includes) do
    local lib_candidates = map_include_to_library(include)
    for _, lib in ipairs(lib_candidates) do
      if lib ~= "" and not lib_set[lib] then
        lib_set[lib] = true
        table.insert(required_libs, lib)
      end
    end
  end

  -- If no libraries detected from includes, return empty
  if #required_libs == 0 then
    return ""
  end

  -- Get priority map
  local priorities = get_library_priority()

  -- Group libraries by family to handle version conflicts
  local lib_families = {}

  for _, lib in ipairs(required_libs) do
    -- Extract library family (e.g., "sdl" from "sdl2" or "sdl3")
    local family = lib:match("^([%a_]+)")

    -- Handle special cases
    if lib:match("^SDL%d+_") then
      local base = lib:match("^(SDL%d+_[%a]+)")
      family = base or family
    elseif lib:match("^Qt%d+") then
      family = "Qt"
    elseif lib:match("^gtk") then
      family = "gtk"
    elseif lib:match("^opencv") then
      family = "opencv"
    end

    if not lib_families[family] then
      lib_families[family] = {lib}
    else
      table.insert(lib_families[family], lib)
    end
  end

  -- Keep only highest priority version of each library family
  local filtered_libs = {}
  for family, libs in pairs(lib_families) do
    if #libs == 1 then
      table.insert(filtered_libs, libs[1])
    else
      -- Sort by priority (highest first)
      table.sort(libs, function(a, b)
        return (priorities[a] or 0) > (priorities[b] or 0)
      end)
      -- Try libraries in priority order until one exists
      for _, lib in ipairs(libs) do
        if check_pkg_config(lib) then
          table.insert(filtered_libs, lib)
          break
        end
      end
    end
  end

  -- Check which libraries are actually available and get their flags
  local detected = {}
  local flags_list = {}

  for _, lib in ipairs(filtered_libs) do
    if check_pkg_config(lib) then
      local flags = get_pkg_config_flags(lib)
      if flags then
        table.insert(detected, lib)
        table.insert(flags_list, flags)
      end
    end
  end

  -- Add special compiler flags for certain includes
  local special_flags = {}
  if includes["omp.h"] then
    table.insert(special_flags, "-fopenmp")
    table.insert(detected, "OpenMP")
  end

  -- Notify user of detected libraries
  if #detected > 0 then
    vim.notify("Auto-detected: " .. table.concat(detected, ", "), vim.log.levels.INFO)
  end

  local all_flags = table.concat(flags_list, " ")
  if #special_flags > 0 then
    all_flags = all_flags .. " " .. table.concat(special_flags, " ")
  end

  return all_flags
end

-- Helper: get manual OpenGL flags for systems without pkg-config
local function get_manual_opengl_flags(files)
  -- Check if OpenGL is needed
  local includes = scan_includes(files)
  local needs_opengl = false

  for include, _ in pairs(includes) do
    if include:match("^GL/") or include:match("OpenGL") or
       include:match("^GLFW/") or include:match("glfw") or
       include:match("SDL_opengl") then
      needs_opengl = true
      break
    end
  end

  if not needs_opengl then
    return ""
  end

  local system = vim.loop.os_uname().sysname

  if system == "Linux" then
    return "-lGL -lGLU"
  elseif system == "Darwin" then
    return "-framework OpenGL -framework Cocoa -framework IOKit -framework CoreVideo"
  elseif system:match("Windows") or system:match("MINGW") or system:match("MSYS") then
    return "-lopengl32 -lglu32"
  end

  return ""
end

-- Helper: generate compile_commands.json
local function generate_compile_commands(entry_point, files, arguments)
  local cwd = vim.fn.getcwd()
  local commands = {}

  -- Split files string into individual files
  local file_list = {}
  for file in files:gmatch("[^%s]+") do
    local clean_file = file:gsub('"', '')
    file_list[#file_list + 1] = clean_file
  end

  -- Create a compilation database entry for each file
  for _, file in ipairs(file_list) do
    local abs_file = file
    if not file:match("^/") and not file:match("^%a:") then
      abs_file = cwd .. "/" .. file
    end

    commands[#commands + 1] = {
      directory = cwd,
      command = "g++ " .. arguments .. " -c " .. file,
      file = abs_file
    }
  end

  -- Write to compile_commands.json
  local json_content = vim.fn.json_encode(commands)
  local output_file = cwd .. "/compile_commands.json"
  vim.fn.writefile({json_content}, output_file)

  return output_file
end

--- Frontend - options displayed on telescope
M.options = {
  { text = "Build and run program", value = "option1" },
  { text = "Build program", value = "option2" },
  { text = "Run program", value = "option3" },
  { text = "Build solution", value = "option4" },
  { text = "", value = "separator" },
  { text = "Generate Compile Commands", value = "option5" }
}

--- Backend - overseer tasks performed on option selected
function M.action(selected_option)
  local utils = require("compiler.utils")
  local overseer = require("overseer")
  local entry_point = utils.os_path(vim.fn.getcwd() .. "/main.cpp")          -- working_directory/main.c
  local files = utils.find_files_to_compile(entry_point, "*.cpp", true)      -- *.cpp files under entry_point_dir (recursively)
  local output_dir = utils.os_path(vim.fn.getcwd() .. "/bin/")               -- working_directory/bin/
  local output = utils.os_path(vim.fn.getcwd() .. "/bin/program")            -- working_directory/bin/program

  -- Autodetect libraries based on actual includes in source files
  local detected_flags = autodetect_libraries(files)

  -- Always check for OpenGL needs and add manual flags if detected
  local manual_gl = get_manual_opengl_flags(files)
  if manual_gl ~= "" then
    if detected_flags ~= "" then
      detected_flags = detected_flags .. " " .. manual_gl
    else
      detected_flags = manual_gl
    end
    vim.notify("Added OpenGL linking flags", vim.log.levels.INFO)
  end

  local arguments = "-Wall -Wextra -g -std=c++17 " .. detected_flags         -- arguments can be overriden in .solution
  local final_message = "--task finished--"


  if selected_option == "option1" then
    local task = overseer.new_task({
      name = "- C++ compiler",
      strategy = { "orchestrator",
        tasks = {{ name = "- Build & run program → \"" .. entry_point .. "\"",
          cmd = "rm -f \"" .. output .. "\" || true" ..                           -- clean
              " && mkdir -p \"" .. output_dir .. "\"" ..                          -- mkdir
              " && g++ " .. files .. " -o \"" .. output .. "\" " .. arguments ..  -- compile
              " && \"" .. output .. "\"" ..                                       -- run
              " && echo \"\n" .. entry_point .. "\"" ..                             -- echo
              " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        },},},})
    task:start()
  elseif selected_option == "option2" then
    local task = overseer.new_task({
      name = "- C++ compiler",
      strategy = { "orchestrator",
        tasks = {{ name = "- Build program → \"" .. entry_point .. "\"",
          cmd = "rm -f \"" .. output .. "\" || true" ..                           -- clean
              " && mkdir -p \"" .. output_dir .. "\"" ..                          -- mkdir
              " && g++ " .. files .. " -o \"" .. output .. "\" " .. arguments ..  -- compile
              " && echo \"\n" .. entry_point .. "\"" ..                             -- echo
              " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        },},},})
    task:start()
  elseif selected_option == "option3" then
    local task = overseer.new_task({
      name = "- C++ compiler",
      strategy = { "orchestrator",
        tasks = {{ name = "- Run program → \"" .. output .. "\"",
          cmd = "\"" .. output .. "\"" ..                                         -- run
              " && echo \"" .. output .. "\"" ..                                  -- echo
              " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        },},},})
    task:start()
  elseif selected_option == "option4" then
    local entry_points
    local task = {}
    local tasks = {}
    local executables = {}

    -- if .solution file exists in working dir
    local solution_file = utils.get_solution_file()
    if solution_file then
      local config = utils.parse_solution_file(solution_file)

      for entry, variables in pairs(config) do
        if entry == "executables" then goto continue end
        entry_point = utils.os_path(variables.entry_point)
        files = utils.find_files_to_compile(entry_point, "*.cpp")
        output = utils.os_path(variables.output)
        output_dir = utils.os_path(output:match("^(.-[/\\])[^/\\]*$"))
        arguments = variables.arguments or arguments -- optional
        task = { name = "- Build program → \"" .. entry_point .. "\"",
          cmd = "rm -f \"" .. output .. "\" || true" ..                           -- clean
              " && mkdir -p \"" .. output_dir .. "\"" ..                          -- mkdir
              " && g++ " .. files .. " -o \"" .. output .. "\" " .. arguments ..  -- compile
              " && echo \"\n" .. entry_point .. "\"" ..                             -- echo
              " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        }
        table.insert(tasks, task) -- store all the tasks we've created
        ::continue::
      end

      local solution_executables = config["executables"]
      if solution_executables then
        for entry, executable in pairs(solution_executables) do
          executable = utils.os_path(executable, true)
          task = { name = "- Run program → " .. executable,
            cmd = executable ..                                                   -- run
                  " && echo \"" .. executable .. "\"" ..                          -- echo
                  " && echo \"" .. final_message .. "\"",
            components = { "default_extended" }
          }
          table.insert(executables, task) -- store all the executables we've created
        end
      end

      task = overseer.new_task({
        name = "- C++ compiler", strategy = { "orchestrator",
          tasks = {
            tasks,        -- Build all the programs in the solution in parallel
            executables   -- Then run the solution executable(s)
          }}})
      task:start()

    else -- If no .solution file
      -- Create a list of all entry point files in the working directory
      entry_points = utils.find_files(vim.fn.getcwd(), "main.cpp")

      for _, entry_point in ipairs(entry_points) do
        entry_point = utils.os_path(entry_point)
        files = utils.find_files_to_compile(entry_point, "*.cpp")
        output_dir = utils.os_path(entry_point:match("^(.-[/\\])[^/\\]*$") .. "bin")  -- entry_point/bin
        output = utils.os_path(output_dir .. "/program")                              -- entry_point/bin/program
        task = { name = "- Build program → \"" .. entry_point .. "\"",
          cmd = "rm -f \"" .. output .. "\" || true" ..                          -- clean
              " && mkdir -p \"" .. output_dir .. "\"" ..                         -- mkdir
              " && g++ " .. files .. " -o \"" .. output .. "\" " .. arguments .. -- compile
              " && echo \"" .. entry_point .. "\"" ..                            -- echo
              " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        }
        table.insert(tasks, task) -- store all the tasks we've created
      end

      task = overseer.new_task({ -- run all tasks we've created in parallel
        name = "- C++ compiler", strategy = { "orchestrator", tasks = tasks }
      })
      task:start()
    end
  elseif selected_option == "option5" then
    local output_file = generate_compile_commands(entry_point, files, arguments)

    local task = overseer.new_task({
      name = "- Generate compile_commands.json",
      strategy = { "orchestrator",
        tasks = {{ name = "- Generate compile_commands.json → \"" .. output_file .. "\"",
          cmd = "echo 'Generated: " .. output_file .. "'" ..
                " && echo \"" .. final_message .. "\"",
          components = { "default_extended" }
        },},},})
    task:start()

    vim.notify("Generated: " .. output_file, vim.log.levels.INFO)
  end
end

return M
